这道题的思路比较难以记忆
前缀和 + 哈希表

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size(), res = 0;
        unordered_map<int,int> mp;
        vector<int> s(n+1,0);

        for(int i = 0;i<n;i++)
        {
            s[i+1] = s[i] + nums[i];
        }

        for(auto sj:s)
        {
            int si = sj - k;
            if(mp[si]!=0)
            {
                res += mp[si];
            }

            mp[sj]++;
        }

        return res;
    }
};
```

空间进一步优化：

```cpp
#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> prefixSumCount; // 哈希表：key-前缀和，value-出现次数
        prefixSumCount[0] = 1; // 初始化，前缀和为0出现1次

        int currSum = 0; // 当前前缀和
        int count = 0;   // 结果计数器

        for (int num : nums) {
            currSum += num; // 更新当前前缀和
            int need = currSum - k; // 计算需要找的前缀和

            // 如果 need 在哈希表中存在，则说明找到了满足条件的子数组
            if (prefixSumCount.find(need) != prefixSumCount.end()) {
                count += prefixSumCount[need];
            }

            // 将当前前缀和加入哈希表
            prefixSumCount[currSum]++;
        }
        return count;
    }
};

```
