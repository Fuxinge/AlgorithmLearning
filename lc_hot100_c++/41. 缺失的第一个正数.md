## 原地哈希

解法一：空间复杂度O(n)不符合要求：

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size(),max_num = -0x3f3f3f3f;
        unordered_set<int> st;
        for(auto x:nums)
        {
            max_num = max(max_num,x);
            st.insert(x);
        }

        for(int i = 1;i<=n;i++)
        {
            if(st.find(i)==st.end()) return i;
        }

        if(max_num + 1 <= 0) return 1;
        else return n+1;
    }
};
```

解法二：符号标记法

这种方法通过将对应位置的数值变为负数来标记一个数字的存在。

1.数据预处理：首先，遍历数组，将所有负数、零和大于数组长度 n的数替换为一个安全值（如 n+1），因为它们不影响寻找缺失的最小正数。

2.索引标记：再次遍历数组。对于每个元素的绝对值 x，如果 x在 1到 n的范围内，则将数组中第 x-1个位置的元素的值置为负数（如果它还不是负数的话），以此标记数字 x存在。

3.查找结果：最后遍历数组，返回第一个其值仍为正数的元素的下标 i+1。如果所有位置都是负数，说明 1到 n都出现了，则返回 n+1

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();

        // 1. 数据预处理：将无关数字替换为 n+1
        for (int i = 0; i < n; ++i) {
            if (nums[i] <= 0 || nums[i] > n) {
                nums[i] = n + 1;
            }
        }

        // 2. 使用符号标记存在的数字
        for (int i = 0; i < n; ++i) {
            int num = abs(nums[i]); // 取绝对值，因为可能已被标记为负
            if (num <= n) { // 如果这个数字在 1~n 范围内
                // 将对应位置的值标记为负值，表示这个数字存在
                // 使用 abs 确保不会负负得正，重复标记也无妨
                if (nums[num - 1] > 0) {
                    nums[num - 1] = -nums[num - 1];
                }
            }
        }

        // 3. 查找第一个正数，其索引+1即为缺失的数
        for (int i = 0; i < n; ++i) {
            if (nums[i] > 0) {
                return i + 1;
            }
        }

        // 如果 1~n 都出现了，则返回 n+1
        return n + 1;
    }
};
```

### 解法三：位置交换法 (灵神)

这种方法通过交换将数字放到它本该在的正确位置上。

1.归位操作：遍历数组。对于每个元素 nums[i]，如果它的值在 1到 n之间，并且它当前不在它应该在的位置上（即 nums[i]不等于 nums[nums[i] - 1]），就将它与那个正确位置上的元素进行交换。使用 while循环，直到当前元素被换到不在范围内，或者已经被正确归位，或者要交换的两个元素相同（避免死循环）为止。

2.查找结果：遍历归位后的数组，第一个满足 nums[i] != i + 1的位置，其 i+1就是缺失的最小正数。如果所有位置都满足，则返回 n+1。

```cpp
class Solution {
public:
int firstMissingPositive(vector<int>& nums) {
int n = nums.size();

        // 1. 通过交换将数字归位
        for (int i = 0; i < n; ++i) {
            // 使用 while 循环，直到当前元素被处理到不在范围内或归位为止
            while (nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }

        // 2. 查找第一个位置与值不匹配的数
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        return n + 1;
    }

};


```

```

```
