```cpp
class Solution {
public:
    vector<vector<string>> res;
    vector<string> temp;
    int col[20],dg[20],udg[20];
    void dfs(int n,int u)
    {
        if(u == n)
        {
            res.push_back(temp);
            return ;

        }

        for(int i = 0;i<n;i++)
        {
            if(!col[i] && !dg[u+i] && !udg[n-u+i])
            {
                col[i] = dg[i+u] = udg[n-u+i] = 1;
                temp[u][i] = 'Q';
                dfs(n,u+1);
                col[i] = dg[i+u] = udg[n-u+i] = 0;
                temp[u][i] = '.';
            }
        }
    }

    vector<vector<string>> solveNQueens(int n) {
        for(int i = 0;i<n;i++)
        {
            string s = "";
            for(int j = 0;j<n;j++)
            {
                s = s + ".";
            }
            temp.push_back(s);
        }

        dfs(n,0);

        return res;
    }
};
```

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        grid = []
        for i in range(n):
            temp = ""
            for j in range(n):
                temp+='.'
            grid.append(temp)

        col = [False] * n
        dg = [False] * (n * 2) # 这里的实际索引是0到2n-2
        udg = [False] * (n * 2 ) # 这里的实际索引范围是1到2n-1,所以要开2n个

        def dfs(i):
            if i == n:
                res.append(grid.copy())
                return

            for c in range(n):
                if not col[c] and not dg[c + i] and not udg[n - i + c]:
                    col[c] = dg[c + i ] = udg[n - i + c] = True
                    temp = grid[i]
                    grid[i] = grid[i][:c] + 'Q' + grid[i][c+1:]
                    dfs(i + 1)
                    col[c] = dg[c + i ] = udg[n - i + c] = False
                    grid[i] = temp

        dfs(0)

        return res

```
