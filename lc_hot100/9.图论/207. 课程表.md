# 拓扑排序

## acwing写法

注意要用numcourese和cnt比较而不是边数n

```cpp
class Solution {
public:
    static const int N = 10001;
    int e[N*2],ne[N*2],d[N],idx,h[N];
    void add(int a,int b)
    {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

        int n = prerequisites.size();
        memset(h,-1,sizeof(h));
        for(int i = 0;i<prerequisites.size();i++)
        {
            add(prerequisites[i][1],prerequisites[i][0]);
            d[prerequisites[i][0]] ++;
        }
        queue<int> q;

        for(int i = 0;i<numCourses;i++)
        {
            if(d[i]==0) q.push(i);
        }

        int cnt = q.size();


        while(q.size())
        {
            auto t = q.front();
            q.pop();
            for(int i = h[t];i!=-1;i = ne[i])
            {
                auto j = e[i];
                d[j]--;
                if(d[j]==0)
                {
                    q.push(j);
                    cnt++;
                }
            }

        }

        return numCourses==cnt;
    }
};
```

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        d = [0] * numCourses
        mp = defaultdict(list)
        q = deque()

        for i,row in enumerate(prerequisites):
            d[row[0]] += 1
            mp[row[1]].append(row[0])

        for i in range(numCourses):
            if d[i] == 0:
                q.append(i)
        res = []
        while q:
            t = q[0]
            q.popleft()
            res.append(t)

            for c in mp[t]:
                d[c] -= 1
                if d[c] == 0:
                    q.append(c)

        return len(res) == numCourses
```
