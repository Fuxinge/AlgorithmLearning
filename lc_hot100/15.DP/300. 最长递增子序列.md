纯DP做法 O(n^2)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size(),res = 0;

        // 以第i个元素为结尾的最长上升子序列的长度
        vector<int> dp(n,0);

        for(int i = 0;i<n;i++)
        {
            dp[i] = 1;
            for(int j = 0;j<i;j++)
            {
                if(nums[i] > nums[j])
                {
                    dp[i] = max(dp[i],dp[j] + 1);
                }
            }
            res = max(res,dp[i]);
        }

        return res;
    }
};
```

贪心+二分做法 O(nlogn)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();

        vector<int> low;
        for(auto x: nums)
        {
            auto it = lower_bound(low.begin(),low.end(),x);
            if(it == low.end())
            {
                low.push_back(x);
            }
            else *it = x;
        }

        int res = low.size();

        return res;
    }
};
```

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        low = []
        n = len(nums)

        for x in nums:
            it = bisect_left(low,x)
            if it == len(low):
                low.append(x)
            else :
                low[it] = x

        return len(low)
```
