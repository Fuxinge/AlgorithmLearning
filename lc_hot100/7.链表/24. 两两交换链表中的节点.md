# 按照25. K 个一组翻转链表的写法来做

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
// class Solution {
// public:
//     ListNode* swapPairs(ListNode* head) {
//         int k = 2, cnt = 0,len = 0;
//         auto cur = head;
//         while(cur)
//         {
//             len ++;
//             cur = cur->next;
//         }

//         cnt = len / 2;
//         auto dummy = new ListNode();

//         auto p0 = dummy;
//         ListNode *pre = nullptr;
//         dummy->next = head;
//         cur = head;

//         while(cnt--)
//         {
//             for(int i = 0;i<k;i++)
//             {
//                 auto nxt = cur->next;
//                 cur->next = pre;
//                 pre = cur;
//                 cur = nxt;
//             }
//             auto nex = p0->next;
//             p0->next->next = cur;
//             p0->next = pre;
//             p0 = nex;
//         }

//         return dummy->next;
//     }
// };
```

## AI给的更好理解的一版

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 翻转链表并返回新的头结点
    ListNode* reverseList(ListNode* head)
    {
        ListNode *cur = head,*pre = nullptr;
        while(cur)
        {
            auto nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }

        return pre;
    }
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummy = new ListNode();
        dummy->next = head;
        int k = 2;
        //pre用于标记当前待翻转子链表的前一个节点，end用于寻找当前子链表的末尾。
        auto pre = dummy,end = dummy;

        while(end->next != nullptr)
        {
            for(int i = 0;i < k && end!=nullptr;i++)
            {
                end = end->next;
            }
            if(!end) break;
            // start当前组的起始节点
            auto nextGroup  = end->next,start = pre->next;
            end->next = nullptr;
            auto newHead = reverseList(start);
            pre->next = newHead;
            start->next = nextGroup;

            pre = start;
            end = pre;
        }

        return dummy->next;
    }
};
```
