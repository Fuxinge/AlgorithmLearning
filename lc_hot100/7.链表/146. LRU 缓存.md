LRU（最近最少使用）缓存是一种高效的缓存管理策略，其核心思想是“如果数据最近被访问过，那么将来被访问的概率也更高”。当缓存空间不足时，它会优先淘汰最久未被访问的数据 。下面我们深入探讨如何设计一个能在 O(1)​ 时间复杂度内完成 get和 put操作的 LRU 缓存。

## LRU 的核心思想

LRU 算法的运作非常直观，它基于时间局部性原理​ 。你可以将缓存想象成一个队列，其容量是固定的：

1. 访问数据时：如果数据在缓存中（缓存命中），则将其移动到队列的头部，标记为“最近使用”。
2. 插入数据时：

如果数据不在缓存中且缓存未满，则直接将新数据放入队列头部。

如果数据不在缓存中且缓存已满，则需要将队列尾部的数据（即“最久未使用”的数据）移除，然后将新数据放入头部

```cpp
class Node{
public:
    int key,value;
    Node * prev;
    Node * next;

    Node(int k = 0,int v = 0):key(k),value(v){}
};

class LRUCache {
    int capacity;
    Node *dummy;
    unordered_map<int,Node *> key_to_node;
public:
    LRUCache(int capacity) {
        this->capacity = capacity;
        dummy = new Node();
        dummy->next = dummy;
        dummy->prev = dummy;
    }

    void push_front(Node* x)
    {
        x->prev = dummy;
        x->next = dummy->next;
        dummy->next = x;
        x->next->prev = x;
    }

    void remove(Node * node)
    {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    Node *get_Node(int key)
    {
        auto it = key_to_node.find(key);
        if(it==key_to_node.end()) return nullptr;

        Node* node = it->second;
        remove(node);
        push_front(node);
        return node;
    }

    int get(int key) {
        Node* node = get_Node(key);
        return node?node->value:-1;
    }

    void put(int key, int value) {
        Node * node = get_Node(key);
        if(node)
        {
            node->value = value;
            return;
        }
        key_to_node[key] = node = new Node(key,value);
        push_front(node);
        if(key_to_node.size()>capacity)
        {
            // 这里要单独定义出来back_node，不然delete会报错
            auto back_node = dummy->prev;
            key_to_node.erase(back_node->key);
            remove(back_node);
            delete back_node;
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```
