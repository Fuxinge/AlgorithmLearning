这道题的思路比较难以记忆
前缀和 + 哈希表

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size(), res = 0;
        unordered_map<int,int> mp;
        vector<int> s(n+1,0);

        for(int i = 0;i<n;i++)
        {
            s[i+1] = s[i] + nums[i];
        }

        for(auto sj:s)
        {
            int si = sj - k;
            if(mp[si]!=0)
            {
                res += mp[si];
            }

            mp[sj]++;
        }

        return res;
    }
};
```

空间进一步优化：

```cpp
#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> prefixSumCount; // 哈希表：key-前缀和，value-出现次数
        prefixSumCount[0] = 1; // 初始化，前缀和为0出现1次

        int currSum = 0; // 当前前缀和
        int count = 0;   // 结果计数器

        for (int num : nums) {
            currSum += num; // 更新当前前缀和
            int need = currSum - k; // 计算需要找的前缀和

            // 如果 need 在哈希表中存在，则说明找到了满足条件的子数组
            if (prefixSumCount.find(need) != prefixSumCount.end()) {
                count += prefixSumCount[need];
            }

            // 将当前前缀和加入哈希表
            prefixSumCount[currSum]++;
        }
        return count;
    }
};

```

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        res = 0
        preSum = [0] * (n+1)
        mp = defaultdict(int)
        mp[0] = 1 # 为什么加这个，见问答

        for i,num in enumerate(nums):
            preSum[i+1] = preSum[i] + num

        for sj in preSum:
            si = k - sj
            res += mp[si]
            mp[sj] += 1

        return res
```

问：为什么要把 preSum[0]=0 (s[0]) 也加到哈希表中？

答：举个最简单的例子，nums=[1], k=1。如果不把 s[0]=0 加到哈希表中，按照我们的算法，没法算出这里有 1 个符合要求的子数组。也可以这样理解，要想把任意子数组都表示成两个前缀和的差，必须添加 s[0]=0，否则当子数组是前缀时，没法减去一个数，具体见 前缀和及其扩展 中的讲解。
