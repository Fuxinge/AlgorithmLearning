会背但是总错的思路，

```cpp
class Solution {
public:
    int quick_select(vector<int>& nums, int k,int l,int r)
    {
        if(l == r) return nums[l];
        if(l>r) return -1;

        int i = l - 1, j =r + 1;
        int index = l + rand()%(r - l + 1);
        int pivot = nums[index];

        while(i<j)
        {
            do i++;while(nums[i] < pivot);
            do j--;while(nums[j] > pivot);
            if(i<j) swap(nums[i] ,nums[j]);
        }

        if(k <= j)
        {
            return quick_select(nums,k,l,j);
        }
        else return quick_select(nums,k,j + 1,r);
    }
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size() ;
        int target = n - k;
        return quick_select(nums,target,0,n-1);
    }
};
```

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        n = len(nums)
        l,r = 0,n - 1
        k = n - k
        def quick_select(nums,l,r,k):
            if l>r:
                return -1
            if l == r :
                return nums[l]
            i,j = l, r
            nums[(l + r)//2],nums[l] = nums[l],nums[(l + r)//2]
            x = nums[l]
            while i<=j:
                while i<=j and nums[i] < x:
                    i += 1
                while i<=j and nums[j] > x:
                    j -= 1
                if i<=j:
                    nums[i],nums[j] = nums[j],nums[i]
                    i = i + 1
                    j = j - 1

            if k <= j:
                return quick_select(nums, l, j, k)
            elif k >= i:
                return quick_select(nums, i, r, k)
            else:
                return nums[k]

        return quick_select(nums,0,n-1,k)
```

下面这个思路较好，空间复杂度稍高

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def qs(nums,k):
            n = len(nums)
            smaller,larger,mid = [], [], []
            pivot = random.choice(nums)

            for c in nums:
                if c < pivot:
                    smaller.append(c)
                elif c >pivot:
                    larger.append(c)
                else :
                    mid.append(c)


            if len(larger) >= k :
                return qs(larger,k)
            elif len(larger) + len(mid) >=k:
                return pivot
            else :
                return qs(smaller,k - len(larger) - len(mid))
        return qs(nums,k)
```
